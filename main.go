package ivory

import (
	"bufio"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"math/rand"
	"reflect"
	"strconv"
	"strings"
	"time"

	_ "github.com/lib/pq"
)

// PgMaxIdentifierLen is the longest a postgres identifier may be without truncation.  For our purposes, we consider
// this to be a limit to avoid
//
// The system uses no more than NAMEDATALEN-1 bytes of an identifier. Longer names can be written in commands, but they will be truncated.
// By default, NAMEDATALEN is 64 so the maximum identifier length is 63 bytes.
// more detail: https://www.postgresql.org/docs/14/sql-syntax-lexical.html
//
// Its length is currently defined as 64 bytes (63 usable characters plus terminator), but should be referenced
// using the constant NAMEDATALEN in C source code.
// more detail: https://www.postgresql.org/docs/current/datatype-character.html
const PgMaxIdentifierLen = 63

// we suffix autogenerated db names
const randSuffixLen = 16

// this makes it easy to find our generated DBs
const AutogenDBPrefix = "_disp_pg" // _ is added as a suffix as part of a join

// Calculate how many characters we can use to generate our table name
// +1 for autogenDBPrefix "_" join, +1 for customIdPortion "_" join, but not one for the final randSuffix
const remainingNameBudget = PgMaxIdentifierLen - (len(AutogenDBPrefix) + randSuffixLen + 2)

// these are string replacements, not placeholders that can be substituted
// note %% literal for wildcard in postgres
// only a single database can be dropped at a time.  if not iterating in code, the drop statements can be generated via this format:
//
//	SELECT 'DROP DATABASE "'||datname||'";' FROM pg_database WHERE datname LIKE '_disp_pg%' AND datistemplate = false;
const findCreatedTemplate = `SELECT datname FROM pg_database WHERE datname LIKE '%s%%' AND datistemplate = false;`
const deleteTemplate = `DROP DATABASE IF EXISTS "%s"` // double quote for any upper case

/*
todo: 	having each created dbhandle register at db-creation-time would be a clever way of tracking
 		(e.g. each New() is a sub instance NewSession?) open and/or not dropped databases.
		leaving unimplemented pending need and some thinking about ux
*/

// mightHaveTransaction looks for the start of a transaction in DDL to try to avoid creating tx inside a tx.
// ideally we want to run all user provided sql in a tx to report if we failed setup
func mightHaveTransaction(sqlText string) bool {
	// be naive with simple string matching until we have reason to not be.
	// if this affects you, please open a PR or issue
	evidence1 := "begin statement"
	evidence2 := "begin " // note trailing space -- avoid "beginning" or other innocent usage. prefer string cmp over regex (`begin\ (statement)?`)

	scanner := bufio.NewScanner(strings.NewReader(sqlText))
	for scanner.Scan() {
		lowerSQL := strings.ToLower(scanner.Text())
		if strings.Contains(lowerSQL, evidence1) || strings.Contains(lowerSQL, evidence2) {
			return true
		}
	}
	return false
}

// New creates a new database, offering some parameters for adjusting behavior.
//
// opts is a set of database options to pass into the function.  an empty database name in opts results in an automatically generated name.
// sqlText are SQL statements that are run in order
// createDatabase does what you expect, but if the database does not exist, an error will return when New() tries to create a handle.
// customIdPortion is an optional string that allows for specifying _disp_pg_<SOME STRING>__bfpmfckppdetem30
//
// todo: customIdPortion maybe doesn't make sense
//
// return is:
//   - db handle without the db open
//   - db handle with the db open
//   - the name of the db
//   - a teardown/cleanup function specific to a DB (the connection not associated with a given db is closed in this function)
//
// The teardown function must be called to clean up resources after work is complete.
// Not calling the teardown can also be useful if you want resources to persist for whatever reason
// (such as single threaded tests with up/down migrations or for application instantiation with IF NOT EXISTS).
func New(ctx context.Context, opts *DatabaseOptions, sqlText []string, createDatabase bool, customIdPortion string) (*sql.DB, *sql.DB, string, func() error, error) {

	// bind connection needed for cleanup func as we cannot drop an open database
	userOptsDatabaseName := opts.Database
	opts.Database = ""
	dbHandleNoBoundDB, err := Connect(ctx, opts)
	if err != nil {
		return nil, nil, opts.Database, dbHandleNoBoundDB.Close, err
	}

	// post connection binding without opening the database, store database name for usage
	// (necessary post Connect because we can't provide the DB name on connection if it doesn't exist yet)
	if len(userOptsDatabaseName) > 0 {
		opts.Database = userOptsDatabaseName
	}

	// the provided value could still be an empty string, which we take as a sign to generate a db name
	// do not generate a DB name if we're not creating a database or update our options
	if len(opts.Database) == 0 && createDatabase {
		opts.Database = generateDbName(customIdPortion)
	}

	tearDown := tearDownFunc(ctx, nil, dbHandleNoBoundDB, opts.Database)

	// pinging the database would be useful here, notwithstanding the temporal issue
	// however, Ping() connects to a db that may not exist yet.
	// an alternative is looking at open ports or dialing to see if something is potentially listening
	//
	// similarly, we can't trivially mark errors as classes of execution/connection failures because
	// it's not known for certain which Exec will happen first based on arguments to this function

	if createDatabase {
		_, err = dbHandleNoBoundDB.ExecContext(ctx, fmt.Sprintf(`CREATE DATABASE "%s"`, opts.Database)) // double quote for any upper case
		if err != nil {
			dsn, errDSN := opts.DSN()
			if errDSN != nil {
				dsn = fmt.Sprintf("<unable to generate DSN due to error = %s", errDSN)
			}
			return dbHandleNoBoundDB, nil, opts.Database, tearDown, fmt.Errorf("DSN: %s. %w", dsn, err)
		}
	}

	// with the database now existing, bind a connection that opens the database
	// if the user provides sql text not as options, it's on them to make sure sql (likely migrations) target the
	// correct DB.  in this case, dbHandleNoBoundDB and dbHandleBoundDB are functionally equivalent
	dbHandleBoundDB, err := Connect(ctx, opts)
	if err != nil {
		return dbHandleNoBoundDB, nil, opts.Database, dbHandleBoundDB.Close, err
	}
	// update our teardown func with this additional connection
	tearDown = tearDownFunc(ctx, dbHandleBoundDB, dbHandleNoBoundDB, opts.Database)

	// if there's not an existing transaction, run all user files in a transaction as we don't want to blame our failure on the caller
	txSuspected := false
	for _, sqlText := range sqlText {
		if mightHaveTransaction(sqlText) {
			txSuspected = true
		}
	}
	if !txSuspected {
		transaction, err := dbHandleBoundDB.BeginTx(ctx, nil)
		if err != nil {
			return dbHandleNoBoundDB, dbHandleBoundDB, opts.Database, tearDown, fmt.Errorf("failed to setup transaction. error = %s", err)
		}

		// run user sql files in a transaction we created
		for _, sqlText := range sqlText {
			_, err = dbHandleBoundDB.ExecContext(ctx, sqlText)
			if err != nil {
				return dbHandleNoBoundDB, dbHandleBoundDB, opts.Database, tearDown, fmt.Errorf("error in SQL execution: error %s", err)
			}
		}

		err = transaction.Commit()
		if err != nil {
			return dbHandleNoBoundDB, dbHandleBoundDB, opts.Database, tearDown, fmt.Errorf("failed to commit transaction. error = %s", err)
		}
		return dbHandleNoBoundDB, dbHandleBoundDB, opts.Database, tearDown, nil
	}

	// run user sql files without creating our own transaction
	for _, sqlText := range sqlText {
		_, err = dbHandleBoundDB.ExecContext(ctx, sqlText)
		if err != nil {
			return dbHandleNoBoundDB, dbHandleBoundDB, opts.Database, tearDown, fmt.Errorf("error in SQL execution: error %s", err.Error())
		}
	}

	return dbHandleNoBoundDB, dbHandleBoundDB, opts.Database, tearDown, nil
}

// DatabaseOptions is used for connection parameters and setting up our handle
// used to generate a DSN() for connection
type DatabaseOptions struct {
	Host                  string `dsnFormat:"host='%s'"`
	Port                  int    `dsnFormat:"port=%d"`
	Database              string `dsnFormat:"dbname='%s'"`
	Schema                string `dsnFormat:"search_path='%s'"`
	User                  string `dsnFormat:"user='%s'"`
	Password              string `dsnFormat:"password='%s'"`
	SslMode               string `dsnFormat:"sslmode=%s"`
	SslCert               string `dsnFormat:"sslcert='%s'"`
	SslKey                string `dsnFormat:"sslkey='%s'"`
	SslRootCert           string `dsnFormat:"sslrootcert='%s'"`
	ConnectTimeoutSeconds int    `dsnFormat:"connect_timeout=%d"`
	MaxOpenConns          int
	MaxIdleConns          int

	// internal for DSN string generation
	reflectType reflect.Type
}

// ValidSSLModes is used to lookup if a user-provided string is allowed in creating a connection to pg
// https://www.postgresql.org/docs/current/libpq-ssl.html
var ValidSSLModes = map[string]struct{}{
	"disable":     {},
	"allow":       {},
	"prefer":      {},
	"require":     {},
	"verify-ca":   {},
	"verify-full": {},
}

func IsValidSSLString(s string) bool {
	_, ok := ValidSSLModes[s]
	return ok
}

// GetDSNPart gets the DSN string off of the struct
// error should only be thrown based on developer error in this library
func (do *DatabaseOptions) GetDSNPart(fieldName string) (string, error) {

	if do.reflectType == nil {
		do.reflectType = reflect.TypeOf(*do)
	}

	structField, ok := do.reflectType.FieldByName(fieldName)
	if !ok {
		return fmt.Sprintf("missing field in struct: %s", fieldName), nil
	}
	dsnFormat := structField.Tag.Get("dsnFormat")
	if len(dsnFormat) == 0 {
		return fmt.Sprintf("missing dsnFormat hint for field: %s", fieldName), nil
	}
	return dsnFormat, nil
}

// DSN generates a DSN off of database options or returns an error
// it steps over each field of DatabaseOptions instead of using more reflection to get the field
// name, type in addition to the dsn format string in the struct tags
func (do *DatabaseOptions) DSN() (string, error) {
	// slice so we can trivially join and not deal with double spaces
	// for string-comparison internal tests (whitespace trimming isConnectTimeoutSeconds not trivially easy with spaces, special chars valid in postgres fields)
	dsnPortions := make([]string, 0)

	if len(do.Host) > 0 {
		partFmt, err := do.GetDSNPart("Host")
		if err != nil {
			return "", err
		}
		dsnPortions = append(dsnPortions, fmt.Sprintf(partFmt, do.Host))
	}

	if do.Port > 0 {
		partFmt, err := do.GetDSNPart("Port")
		if err != nil {
			return "", err
		}
		dsnPortions = append(dsnPortions, fmt.Sprintf(partFmt, do.Port))
	}

	if len(do.Database) > 0 {
		partFmt, err := do.GetDSNPart("Database")
		if err != nil {
			return "", err
		}
		dsnPortions = append(dsnPortions, fmt.Sprintf(partFmt, do.Database))
	}

	if len(do.Schema) > 0 {
		partFmt, err := do.GetDSNPart("Schema")
		if err != nil {
			return "", err
		}
		dsnPortions = append(dsnPortions, fmt.Sprintf(partFmt, do.Schema))
	}

	if len(do.User) > 0 {
		partFmt, err := do.GetDSNPart("User")
		if err != nil {
			return "", err
		}
		dsnPortions = append(dsnPortions, fmt.Sprintf(partFmt, do.User))
	}

	if len(do.Password) > 0 {
		partFmt, err := do.GetDSNPart("Password")
		if err != nil {
			return "", err
		}
		dsnPortions = append(dsnPortions, fmt.Sprintf(partFmt, do.Password))
	}

	if len(do.SslMode) > 0 {
		if !IsValidSSLString(do.SslMode) {
			return "", fmt.Errorf("invalid ssl mode provided: %s", do.SslMode)
		}

		partFmt, err := do.GetDSNPart("SslMode")
		if err != nil {
			return "", err
		}
		dsnPortions = append(dsnPortions, fmt.Sprintf(partFmt, do.SslMode))
	}

	if len(do.SslCert) > 0 {
		partFmt, err := do.GetDSNPart("SslCert")
		if err != nil {
			return "", err
		}
		dsnPortions = append(dsnPortions, fmt.Sprintf(partFmt, do.SslCert))
	}
	if len(do.SslKey) > 0 {
		partFmt, err := do.GetDSNPart("SslKey")
		if err != nil {
			return "", err
		}
		dsnPortions = append(dsnPortions, fmt.Sprintf(partFmt, do.SslKey))
	}
	if len(do.SslRootCert) > 0 {
		partFmt, err := do.GetDSNPart("SslRootCert")
		if err != nil {
			return "", err
		}
		dsnPortions = append(dsnPortions, fmt.Sprintf(partFmt, do.SslRootCert))
	}

	if do.ConnectTimeoutSeconds > 0 {
		partFmt, err := do.GetDSNPart("ConnectTimeoutSeconds")
		if err != nil {
			return "", err
		}
		dsnPortions = append(dsnPortions, fmt.Sprintf(partFmt, do.ConnectTimeoutSeconds))
	}

	return strings.Join(dsnPortions, " "), nil
}

// Connect uses a DSN to create a database handle to a target dbName
// return is the db handle and an error if setup was prevented
func Connect(ctx context.Context, do *DatabaseOptions) (*sql.DB, error) {

	if ctx.Err() != nil {
		return nil, ctx.Err()
	}

	dsn, err := do.DSN()
	if err != nil {
		return nil, err
	}

	// on postgres, sql.Open does not verify a connection will be successful.
	//
	// the connector for lib/pq takes a DSN string for construction, so unfortunately, we have to build a DSN
	// instead of assigning to struct fields
	db, err := sql.Open("postgres", dsn)
	if err != nil {
		return nil, err
	}

	db.SetMaxOpenConns(do.MaxOpenConns)
	db.SetMaxIdleConns(do.MaxIdleConns)
	return db, nil
}

// generateDBName creates a database name, using the prefix + suffix of this library
// if an empty string is provided, epoch seconds are used
func generateDbName(customIdPortion string) string {
	if len(customIdPortion) == 0 {
		customIdPortion = strconv.FormatInt(time.Now().Unix(), 10)
	}

	if len(customIdPortion) > remainingNameBudget {
		customIdPortion = customIdPortion[:remainingNameBudget]
	}

	// generate a random string.  if a UUID becomes available in the standard lib, consider that instead
	// in go, each rune can be 1-4 bytes long, so we can't make([]byte,32) and rand.Read() into it without creating a
	// byte array of size 4*randSuffixLen
	const charChoices = "abcdefghijklmnopqrstuvwxyz0123456789"
	const charChoiceLen = len(charChoices)

	// a little gross to re-seed each call, but so would be doing this even if not required in New()
	// this is not expected to be needed to be crypto-secure
	rand.Seed(time.Now().UnixNano())

	asciiSlice := make([]byte, randSuffixLen)
	for i := range asciiSlice {
		asciiSlice[i] = charChoices[rand.Intn(charChoiceLen)]
	}
	return strings.Join([]string{AutogenDBPrefix, customIdPortion, string(asciiSlice)}, "_")
}

// tearDownFunc returns a function for dropping a database and closing db handles
func tearDownFunc(ctx context.Context, dbHandleDBOpen *sql.DB, dbHandleNoDBOpen *sql.DB, dbName string) func() error {
	return func() error {
		select {
		case <-ctx.Done():
			errs := []string{"context cancelled before database dropped"}
			err := dbHandleNoDBOpen.Close()
			if err != nil {
				errs = append(errs, err.Error())
			}
			return errors.New(strings.Join(errs, ", "))
		default:
		}

		errs := make([]string, 0)
		_, dropDBErrs := DropDB(ctx, dbHandleNoDBOpen, []string{dbName})
		if len(dropDBErrs) > 0 {
			for _, e := range dropDBErrs {
				errs = append(errs, fmt.Sprintf("dropping database error: %s", e))
			}
		}
		errClose := dbHandleNoDBOpen.Close()
		if errClose != nil {
			errs = append(errs, fmt.Sprintf("*sql.DB without db open. %s", errClose))
		}
		if dbHandleDBOpen != nil {
			errClose = dbHandleDBOpen.Close()
			if errClose != nil {
				errs = append(errs, fmt.Sprintf("*sql.DB with db open. %s", errClose))
			}
		}

		retErr := strings.Join(errs, ", ")
		if len(retErr) > 0 {
			return errors.New(retErr)
		}

		return nil
	}
}

// FindLikelyAbandonedDBs finds databases that were not cleaned up for whatever reason (process crashing, teardown not being called)
// if prefix is an empty string, the AutogenDBPrefix is used
func FindLikelyAbandonedDBs(ctx context.Context, dbHandle *sql.DB, prefix string) ([]string, error) {
	if prefix == "" {
		prefix = AutogenDBPrefix
	}

	selectQuery := fmt.Sprintf(findCreatedTemplate, prefix)
	rows, err := dbHandle.QueryContext(ctx, selectQuery)
	if err != nil {
		return []string{}, err
	}
	results := make([]string, 0)
	for rows.Next() {
		var r string
		err = rows.Scan(&r)
		if err != nil {
			return []string{}, err
		}
		results = append(results, r)
	}
	return results, nil
}

// DropDB drops a slice of databases by name.  It cannot drop the database that is currently open by the dbHandle
func DropDB(ctx context.Context, dbHandle *sql.DB, dbNames []string) ([]sql.Result, []error) {
	results := make([]sql.Result, 0)
	if len(dbNames) == 0 {
		return results, nil
	}
	errs := make([]error, 0)

	for _, dbName := range dbNames {
		res, err := dbHandle.ExecContext(ctx, fmt.Sprintf(deleteTemplate, dbName))
		if res != nil {
			results = append(results, res)
		}
		if err != nil {
			errs = append(errs, err)
		}
	}
	return results, errs
}
